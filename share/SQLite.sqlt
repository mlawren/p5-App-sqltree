/*
    A hierarchical data (tree) implementation using triggers inside the
    database as described here:

    http://www.depesz.com/index.php/2008/04/11/my-take-on-trees-in-sql/

    Generated by [%- program -%] v[%- version -%] on [%- localtime %]
*/

[% IF drop %]
DROP TABLE IF EXISTS [%- table_tree -%];
[% END %]

CREATE TABLE [%- table_tree -%] (
    [% parent_id -%] [%- type -%] NOT NULL
        REFERENCES [%- table -%]([%- id -%]) ON DELETE CASCADE,
    [% id -%] [%- type -%] NOT NULL
        REFERENCES [%- table -%]([%- id -%]) ON DELETE CASCADE,
    depth INTEGER NOT NULL,
    PRIMARY KEY([%- parent_id -%], [%- id -%])
) WITHOUT ROWID;

CREATE UNIQUE INDEX idx_[%- table_tree -%]_[%- id -%]_depth
ON [% table_tree -%]([%- id -%],depth);

/* 
    INSERT:

    1. Insert a matching row in [%- table_tree -%] where both parent
    and child are set to the id of the newly inserted object. Depth is
    set to 0 as both child and parent are on the same level.

    2. In the same statement copy all rows that our parent had as its
    parents, but we modify the child id in these rows to be the id of
    currently inserted row, and increase depth by one.

    3. Update the path of the newly inserted row based on the name and
    parent name columns
*/

[% IF drop %]
DROP TRIGGER IF EXISTS ai_[%- table -%]_insert_tree;
[% END %]

CREATE TRIGGER ai_[%- table -%]_insert_tree
AFTER INSERT ON [%- table %]
FOR EACH ROW 
BEGIN
    INSERT INTO [%- table_tree -%] ([%- parent_id -%], [%- id -%], depth)
    SELECT
        NEW.[%- id -%], -- id
        NEW.[%- id -%], -- parent_id
        0               -- depth
    UNION ALL SELECT
        [% parent_id -%],
        NEW.[%- id -%],
        depth + 1
    FROM [%- table_tree %]
    WHERE [%- id -%] = NEW.[%- parent_id -%];

[% IF path %]
    UPDATE [%- table %]
    SET [%- path -%] = (
        SELECT coalesce(b.[%- path -%] || '[%- separator -%]','')
            || NEW.[%- name %]
        FROM (SELECT 1)
        LEFT JOIN [%- table %] b
        ON b.[%- id -%] = NEW.[%- parent_id %]
    )
    WHERE [%- id -%] = NEW.[%- id -%];
[% END %]

END;

/* 
    BEFORE UPDATE:
    
    1. Forbid moves that would create loops in the tree table

    2. Prevent primary key from changing
*/

[% IF drop %]
DROP TRIGGER IF EXISTS bu_[%- table -%]_loop_check;
[% END %]

CREATE TRIGGER bu_[%- table -%]_loop_check
BEFORE UPDATE OF [%- parent_id -%] ON [%- table %]
FOR EACH ROW WHEN
    NEW.[%- parent_id -%] IS NOT NULL AND
    0 != (
        SELECT count([%- id -%])
        FROM [%- table_tree %]
        WHERE ([%- parent_id -%], [%- id -%]) = (NEW.[%- id %], NEW.[%- parent_id -%])
    )
BEGIN
    SELECT RAISE (ABORT,
        'UPDATE to [%- table -%] blocked, because it would create a loop');
END;

[% IF drop %]
DROP TRIGGER IF EXISTS bu_[%- table -%]_pk_check;
[% END %]

CREATE TRIGGER bu_[%- table -%]_pk_check
BEFORE UPDATE OF [%- id -%] ON [%- table %]
FOR EACH ROW WHEN OLD.[%- id -%] != NEW.[%- id %]
BEGIN
    SELECT raise(ABORT, 'Changing ids is forbidden.');
END;


/* 
    AFTER UPDATE:
    
    1. Forbid moves that would create loops in the tree table

    2. Prevent primary key from changing
*/

[% IF drop %]
DROP TRIGGER IF EXISTS au_[%- table -%]_parent_name_change;
[% END %]

CREATE TRIGGER au_[%- table -%]_parent_name_change
AFTER UPDATE OF [%- parent_id -%]
[%- IF path -%] ,[%- name -%] [%- END -%] ON [%- table %]
FOR EACH ROW WHEN
    (NEW.[%- parent_id -%] IS NOT OLD.[%- parent_id -%])
[% IF path %]
    OR (NEW.[%- name -%] IS NOT OLD.[%- name %])
[% END %]
BEGIN

[% IF path -%]
    INSERT INTO [%- table %]([%- id -%], path)
    SELECT
        src.[% id -%] AS id,
        CASE WHEN
            src.[% id -%] = NEW.[%- id %]
        THEN
            coalesce(np.[%- path -%] || '[%- separator -%]', '')
                || NEW.[%- name %]
        ELSE
            coalesce(np.[%- path -%] || '[%- separator -%]', '')
                || NEW.[%- name %]
                || '[%- separator -%]'
                || substr(src.[%- path -%],
                    length(OLD.[%- path -%] || '[%- separator -%]') + 1)
        END AS path
    FROM [%- table %] src
    LEFT JOIN [%- table -%] np
    ON np.[%- id -%] = NEW.[%- parent_id %]
    WHERE
        src.[%- id -%] IN (
            SELECT DISTINCT [%- id %]
            FROM [%- table_tree %]
            WHERE [%- parent_id -%] = OLD.[%- id %]
        )
    ON CONFLICT ([%- id -%])
    DO UPDATE SET [% path -%] = excluded.path
    ;
[% END %]

    -- Remove the tree data relating to the old parent
    DELETE FROM [%- table_tree %]
    WHERE
        NEW.[%- parent_id -%] IS NOT OLD.[%- parent_id -%] AND
        OLD.[%- parent_id -%] IS NOT NULL AND
        ([%- parent_id -%],[%- id -%]) IN (
            SELECT r2.[%- parent_id -%], r2.[%- id %]
            FROM
                [% table_tree -%] r1
            INNER JOIN
                [% table_tree -%] r2
            ON
                r2.[%- id -%] = r1.[%- id -%] AND r2.depth > r1.depth
            WHERE r1.[%- parent_id -%] = NEW.[%- id %]
          );

    -- Insert tree data relating to the new parent
    INSERT INTO [%- table_tree -%]([%- parent_id -%], [%- id -%], depth)
    SELECT
        r1.[%- parent_id -%],
        r2.[%- id -%],
        r1.depth + r2.depth + 1
    FROM
        [% table_tree -%] r1
    INNER JOIN
        [% table_tree -%] r2
    ON
        r2.[%- parent_id -%] = NEW.[%- id %]
    WHERE
        NEW.[%- parent_id -%] IS NOT OLD.[%- parent_id -%] AND
        NEW.[%- parent_id -%] IS NOT NULL AND
        r1.[%- id -%] = NEW.[%- parent_id %]
    ;

END;

/* vim: set filetype=sql : */
